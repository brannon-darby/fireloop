{"meta":{"title":"Fireloop Documentation","subtitle":"Designed for Modern Real-Time Applications by MEAN Expert.","description":"FireLoop beautifully integrates some of the most amazing frameworks out there; like the IBM's StrongLoop LoopBack, Google's Angular 2, Telerik's NativeScript, Ionic 2 Frameworks and much more.","author":"Mean.Expert","url":"http://fireloop.io"},"pages":[],"posts":[{"title":"Manejar Desconecciones","slug":"handle-disconnections","date":"2017-05-04T21:41:26.411Z","updated":"2017-05-04T21:41:26.411Z","comments":true,"path":"es/handle-disconnections/","link":"","permalink":"http://fireloop.io/es/handle-disconnections/","excerpt":"","text":"FireLoop.io Manejar DesconeccionesA veces, cuando se desconecta un usuario del servidor, es necesario aplicar algunas reglas. Por ejemplo, si su programa es una aplicación de chat, es posible que usted desee mostrar a otros usuarios cuando alguno se ha desconectado. NOTA: Funcionalidad disponible en loopback-component-realtime@1.0.0-rc.6 o superior 1234567891011121314151617181920212223242526272829import &#123; BootScript &#125; from '@mean-expert/boot-script';interface Account &#123; id: string, connected: boolean; updateAttributes: Function;&#125;interface Socket &#123; token: &#123; userId: string &#125; &#125;@BootScript()class OnDisconnect &#123; constructor(public app: any) &#123; app.on('socket-disconnect', (socket: Socket) =&gt; this.handler(socket)); &#125; handler(socket: Socket): void &#123; if (socket.token &amp;&amp; socket.token.userId) &#123; let userId: string = `$&#123; socket.token.userId &#125;` this.app.models.Account.findById(userId, (err: Error, account: Account) =&gt; &#123; console.log('A user has been disconnected:', account.id); account.updateAttributes(&#123; connected: false &#125;); &#125;); &#125; &#125;&#125;module.exports = OnDisconnect;","categories":[],"tags":[]},{"title":"Handle Disconnections","slug":"handle-disconnections","date":"2017-05-04T21:41:11.580Z","updated":"2017-05-04T21:41:11.580Z","comments":true,"path":"en/handle-disconnections/","link":"","permalink":"http://fireloop.io/en/handle-disconnections/","excerpt":"","text":"FireLoop.io Handle DisconnectionsSometimes when a user is disconnected from the server, some business rules required to be applied. For example if your program is a chat application, you might want to show to others when a user disconnects. NOTE: Functionality available on loopback-component-realtime@1.0.0-rc.6 or above 1234567891011121314151617181920212223242526272829import &#123; BootScript &#125; from '@mean-expert/boot-script';interface Account &#123; id: string, connected: boolean; updateAttributes: Function;&#125;interface Socket &#123; token: &#123; userId: string &#125; &#125;@BootScript()class OnDisconnect &#123; constructor(public app: any) &#123; app.on('socket-disconnect', (socket: Socket) =&gt; this.handler(socket)); &#125; handler(socket: Socket): void &#123; if (socket.token &amp;&amp; socket.token.userId) &#123; let userId: string = `$&#123; socket.token.userId &#125;` this.app.models.Account.findById(userId, (err: Error, account: Account) =&gt; &#123; console.log('A user has been disconnected:', account.id); account.updateAttributes(&#123; connected: false &#125;); &#125;); &#125; &#125;&#125;module.exports = OnDisconnect;","categories":[],"tags":[]},{"title":"Creación de modelos FireLoop","slug":"creating-fireloop-models","date":"2017-05-04T21:13:32.975Z","updated":"2017-05-04T21:13:32.975Z","comments":true,"path":"es/creating-fireloop-models/","link":"","permalink":"http://fireloop.io/es/creating-fireloop-models/","excerpt":"","text":"Cuando empiece a construir un sistema, lo primero que debe hacer justo después de su instalación, es comenzar a crear sus Modelos de API. Estos modelos son similares a LoopBack Modelos, pero con una diferencia … Estos modelos serán creados y ejecutados usando TypeScript en lugar de JavaScript. (POW!) Creación de modelos FireLoop1234567891011121314151617181920212223$ cd myproject$ fireloop model MyModel? Enter the model name: MyModel? Select the data-source to attach MyModel to: db (memory)? Select model's base class PersistedModel? Expose MyModel via the REST API? Yes? Custom plural form (used to build REST URL): ? Common model or server only? commonLet's add some MyModel properties now.Enter an empty property name when done.? Property name: text invoke loopback:property? Property type: string? Required? No? Default value[leave blank for none]: Let's add another MyModel property.Enter an empty property name when done.? Property name: Generating: ./common/models/my-model.ts Si usted tiene experiencia con LoopBack verá que es el mismo flujo creacional, es sólo que como se describió anteriormente; El modelo se creará en TypeScript Language. Estructura del ModeloAhora que sus modelos están en TypeScript verá que estos son diferentes en estructura a los LoopBack, pero tiene la misma funcionalidad exacta. 123456789101112131415161718192021222324252627282930313233343536import &#123; Model &#125; from '@mean-expert/model';/** * @module Todo * @description * Write a useful Todo Model description. * Register hooks and remote methods within the * Model Decorator **/@Model(&#123; hooks: &#123; beforeSave: &#123; name: 'before save', type: 'operation' &#125; &#125;, remotes: &#123; myRemote: &#123; returns : &#123; arg: 'result', type: 'array' &#125;, http : &#123; path: '/my-remote', verb: 'get' &#125; &#125; &#125;&#125;)class Todo &#123; // LoopBack model instance is injected in constructor constructor(public model: any) &#123;&#125; // Example Operation Hook beforeSave(ctx: any, next: Function): void &#123; console.log('Todo: Before Save'); next(); &#125; // Example Remote Method myRemote(next: Function): void &#123; this.model.find(next); &#125;&#125;module.exports = Todo;","categories":[],"tags":[]},{"title":"Sirviendo Aplicaciones","slug":"serving-apps","date":"2017-05-04T21:13:32.975Z","updated":"2017-05-04T21:13:32.975Z","comments":true,"path":"es/serving-apps/","link":"","permalink":"http://fireloop.io/es/serving-apps/","excerpt":"","text":"FireLoop.io FireLoop es capaz de ejecutar todas las aplicaciones de su proyecto a la vez (incluyendo su servidor), para esto puede usar el comando fireloop serve y seleccionar las aplicaciones que desea servir. 1234567891011121314151617$ cd myproject$ fireloop serve _-----_ | | ╭──────────────────────────╮ |--(o)--| │ Let's serve an │ `---------´ │ application! │ ( _´U`_ ) ╰──────────────────────────╯ /___A___\\ / | ~ | __'.___.'__ ´ ` |° ´ Y ` ? What application do you want to serve? (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)❯◯ webapp ◯ server Es importante tener en cuenta que tanto las aplicaciones de cliente como de servidor se ejecutarán en TypeScript y se cargarán con mecanismos livereload según el entorno. Esto significa que una vez que sus aplicaciones se estén ejecutando, éstas serán reiniciadas por cualquier modificación de código y recompiladas para ser recargadas en vivo.","categories":[],"tags":[]},{"title":"Escalando FireLoop","slug":"scaling-fireloop","date":"2017-05-04T21:13:32.975Z","updated":"2017-05-04T21:13:32.975Z","comments":true,"path":"es/scaling-fireloop/","link":"","permalink":"http://fireloop.io/es/scaling-fireloop/","excerpt":"","text":"FireLoop.io Escalando FireLoopConstruir aplicaciones con FireLoop es agradable y fácil, pero no valdría nada si la plataforma no escalara a varios servidores o incluso procese instancias. La siguiente documentación explicará cómo habilitar FireLoop para trabajar en entornos agrupados. Requerimientos SDK Builder v2.1.0-rc.10+ LoopBack Component Real-Time v1.0.0-rc.5+ Socket IO Adaptador (cualquier socket.io-adapter como socket.io-adapter-mongo, socket.io-redis, etc) PubSub capa de base de datos como MongoDB o Redis Creando el DataSourceIndependientemente del origen de datos que seleccione para sus modelos de API, deberá crear una fuente de datos que apunte a una base de datos MongoDB o Redis. Si ya seleccionó MongoDB o Redis como base de datos para sus Modelos de API, no necesitará crear una nueva fuente de datos, los usuarios que utilicen otras bases de datos como SQL, requerirá crear una nueva fuente de datos apuntando a MongoDB O Redis e instale su correspondiente dependencia de LoopBack. 12$ cd to/project/api$ npm install --save [loopback-connector-mongodb | loopback-connector-redis] y como cualquier otro origen de datos LoopBack, se configura de la siguiente forma: 1234567&#123; \"mongodb\": &#123; \"url\": \"mongodb://user:pass@host:27016/dbname\", \"name\": \"mongodb\", \"connector\": \"mongodb\" &#125;&#125; server/datasources.json Habilitar el modo ClusteringPara habilitar el modo de Clustering, necesitamos realizar las siguientes configuraciones: 123456789101112131415&#123; \"@mean-expert/loopback-component-realtime\": &#123; \"auth\": true, \"debug\": false, \"driver\": &#123; \"name\": \"socket.io\", \"options\": &#123; \"adapter\": &#123; \"name\": \"socket.io-adapter-mongo\", \"datasource\": \"mongodb\" &#125; &#125; &#125; &#125;&#125; Tenga en cuenta que adapter.name debe ser el adaptador que ha seleccionado e instalado antes de este proceso, así como eladapter.datasource debe ser el nombre de la fuente de datos que ha creado. Después de seguir las configuraciones anteriores, FireLoop funcionará en entornos de procesos o servidores agrupados.","categories":[],"tags":[]},{"title":"Ejemplo de Estatisticas RealTime","slug":"realtime-stats-example","date":"2017-05-04T21:13:32.975Z","updated":"2017-05-04T21:13:32.975Z","comments":true,"path":"es/realtime-stats-example/","link":"","permalink":"http://fireloop.io/es/realtime-stats-example/","excerpt":"","text":"Real-Time Descripción del ProyectoPara demostrar lo que se puede lograr con FireLoop, he decidido crear una aplicación que procese gráficos estadísticos con datos en tiempo real procedentes de un proyecto FireLoop. Este será un tipo de aplicación Todo Todo, pero esta vez vamos a fijar una fecha de vencimiento para todos nuestros, de esta manera podemos hacer alguna información estadística sobre ella y jugar mejor con ella. Repositorio del proyectoPara este ejemplo he creado un repositorio que puedes usar como patio de recreo. HAGA CLIC AQUÍ PARA GITHUB REPO Instalar FireLoopPor supuesto, el primer paso que queremos tomar es instalar nuestra Herramienta de CLI FireLoop. 1$ npm install -g @mean-expert/fireloop Crear proyecto FireLoop.Ahora que tenemos nuestra Herramienta CLI FireLoop instalada, podemos seguir adelante y crear nuestro primer proyecto FireLoop. Para crear un proyecto FireLoop, necesitará crear un nuevo directorio de carpetas en cualquier ubicación de sistema de archivos de su preferencia, luego ejecutar el comando $ fireloop y finalmente pulsar return para todas las opciones mostradas. 1234567891011121314151617181920212223242526272829303132$ mkdir fireloop_project &amp;&amp; cd fireloop_project$ fireloop _-----_ ╭──────────────────────────╮ | | │ Welcome to FireLoop! │ |--(o)--| │ The MEAN Stack Platform │ \\`---------´ │ by MEAN Expert │ ( _´U`_ ) ╰──────────────────────────╯ /___A___\\ / | ~ | __'.___.'__ ´ ` |° ´ Y \\` ? What do you want to do? (Use arrow keys)❯ Generate FireLoop Project Show FireLoop Version ? What\\'s the name of your application? fireloop_project? Which version of LoopBack would you like to use? 2.x (stable)? What kind of application do you have in mind? api-server (A LoopBack API server with local User auth)Next steps: Create a model in your server $ fireloop model [ModelName] Create a new Angular 2 Client or SDK $ fireloop Serve an application $ fireloop serve Genial, ahora hemos creado un proyecto FireLoop con la cantidad mínima de esfuerzo. Así que … ¿qué pasa si seguimos los consejos de los ‘próximos pasos’ y luego simplemente creamos nuestro modelo Todo. Crear Modelo TodoPara ello vamos a utilizar el comando $ fireloop model [ModelName] y luego añadir un par de propiedades. Básicamente, simplemente pulsa return hasta llegar a la sección de propiedades y agrega los atributos text: string &amp;&amp; dueAt: date. 123456789101112131415161718192021222324252627282930$ fireloop model Todo? Enter the model name: Todo? Select the data-source to attach Todo to: db (memory)? Select model´s base class PersistedModel? Expose Todo via the REST API? Yes? Custom plural form (used to build REST URL): ? Common model or server only? commonLet´s add some Todo properties now. Property text: stringEnter an empty property name when done.? Property name: text? Property type: string? Required? Yes? Default value[leave blank for none]: Property dueAt: dateLet´s add another Todo property.Enter an empty property name when done.? Property name: dueAt? Property type: date? Required? Yes? Default value[leave blank for none]: Let´s add another Todo property.Enter an empty property name when done.? Property name: Generating: ./common/models/todo.ts Si ha estado usando LoopBack, notará que bajo el capó estoy usando el generador de loopback para esta operación, pero al final; La herramienta FireLoop CLI toma el control y creará una versión modificada de un modelo LoopBack. Si abre el archivo . / Common / models / todo.ts, encontrará la nueva estructura TypeScript para nuestros modelos de back-end. 123456789101112131415161718192021222324252627282930313233343536import &#123; Model &#125; from '@mean-expert/model';/** * @module Todo * @description * Write a useful Todo Model description. * Register hooks and remote methods within the * Model Decorator **/@Model(&#123; hooks: &#123; beforeSave: &#123; name: 'before save', type: 'operation' &#125; &#125;, remotes: &#123; myRemote: &#123; returns : &#123; arg: 'result', type: 'array' &#125;, http : &#123; path: '/my-remote', verb: 'get' &#125; &#125; &#125;&#125;)class Todo &#123; // LoopBack model instance is injected in constructor constructor(public model: any) &#123;&#125; // Example Operation Hook beforeSave(ctx: any, next: Function): void &#123; console.log('Todo: Before Save'); next(); &#125; // Example Remote Method myRemote(next: Function): void &#123; this.model.find(next); &#125;&#125;module.exports = Todo; Cualquier lógica relacionada con nuestro Modelo Todo en el Back-End debe colocarse en este archivo TypeScript, aunque para esta demo lo vamos a dejar como está. Pero, lo que realmente queremos hacer es actualizar nuestras configuraciones estadísticas de Todo el Modelo. Abra el archivo / common / models / todo.json y actualícelos de la manera siguiente: 1234567891011121314&#123; ... \"mixins\": &#123; ... \"Stats\": [ &#123; ... \"count\": &#123; \"on\": \"dueAt\" // &lt;---- cambia createdAt por dueAt &#125; &#125; ] &#125;&#125; Lo que estamos haciendo aquí es decir que las estadísticas se mezclan para confiar en la propiedad dueAt, de esta manera nuestra información estadística se generará de acuerdo a las fechas de entrega de todo en lugar de cuando se creó el todo Desactivar la función AuthPara este proyecto y para fines prácticos, no utilizaremos el mecanismo de autenticación ya que no quiero dedicar tiempo a crear secciones de registro / inicio de sesión, pero prometo que voy a crear un tutorial para la autenticación muy pronto. Para ello, abra el archivo server/component-config.json y modifíquelo de la siguiente manera: 123456789&#123; \"loopback-component-explorer\": &#123; \"mountPath\": \"/explorer\" &#125;, \"@mean-expert/loopback-component-realtime\": &#123; \"auth\": false, // &lt;--- Change this to false \"debug\": false &#125;&#125; Ok, para este proyecto … Eso es todo lo que necesitamos hacer dentro de nuestro Back End. Ahora, es hora de crear nuestro Angular 2 Cliente. Crear cliente Web Angular 2Podemos crear clientes Angular 2 usando el comando FireLoop: $ fireloop 1234567891011121314151617$ fireloop _-----_ ╭──────────────────────────╮ | | │ Welcome to FireLoop! │ |--(o)--| │ The MEAN Stack Platform │ `---------´ │ by MEAN Expert │ ( _´U`_ ) ╰──────────────────────────╯ /___A___\\ / | ~ | __'.___.'__ ´ ` |° ´ Y ` ? What do you want to do? (Use arrow keys)❯ Generate Angular2 Client ? What type of Angular 2 Application do you want to create? Angular 2 for Web? What's the name of your application? webapp Al seguir el proceso descrito anteriormente, suceden varias cosas bajo el capó. FireLoop Internamente utiliza Angular CLI para crear un proyecto Angular 2. FireLoop Genera un SDK para que su nueva aplicación cliente Angular 2 esté totalmente conectada con su API LoopBack. FireLoop Instala el SDK y sus dependencias, incluidos los tipos. Al final del proceso no tendrá que preocuparse por ninguna integración o configuración, todo se ha hecho automáticamente para usted !!!.[El público anima en el fondo :D] Instalar NG2 ChartsAhora que ha evitado una buena cantidad de configuraciones e integraciones, está listo para comenzar a trabajar sobre la aplicación cliente. Para este proyecto he decidido utilizar Ng2Charts para procesar nuestros gráficos, pero también puedes comprobar Este tutorial para crear sus propios gráficos personalizados. 12$ cd webapp$ npm install --save ng2-charts chart.js moment Personalización de la estructura del sistema de archivosComo puedes ver, debes ingresar el directorio de la aplicación web (o cualquier nombre que hayas elegido para tu aplicación) y luego instalar desde allí tus propias dependencias. Esto se debe a que aunque tengamos un espacio de trabajo para ello, queremos mantener las dependencias y los clientes reales tan desacoplados como sea posible del servidor. Esto significa que no es necesario tener en 1 lugar los módulos para el servidor y los módulos para NativeScript porque no tiene sentido. Entonces … ¿Por qué entonces estamos creando todo dentro del mismo proyecto? La respuesta corta es por comodidad, porque recuerde que FireLoop integra para usted una solución de pila completa, lo que le permite crear automáticamente sdks para cualquiera de sus clientes y agregar funcionalidades exclusivas en tiempo real y estadística sin ninguna configuración o esfuerzo adicional. Pero, si realmente no te gusta tener tu webapp o cualquier cliente dentro del mismo directorio que el proyecto FireLoop, puedes cambiarlo. Simplemente abra el archivo .yo-rc.json y actualice la ruta del cliente a cualquier ubicación de su preferencia 123456789101112&#123; \"generator-fireloop\": &#123; \"version\": \"1.0.0-beta.1\", \"clients\": &#123; \"webapp\": &#123; \"path\": \"./webapp\", // &lt;--- Move your project out of the FireLoop directory and update the path reference here \"type\": \"web\" &#125; &#125; &#125;, \"generator-loopback\": &#123;&#125;&#125; Por supuesto, usted puede desear mover algunos de estos clientes lejos; Porque es posible que desee tener depósitos separados y sólo porque no tiene sentido tenerlo en un lugar cuando se habla de aplicaciones móviles. Sólo recuerde que todavía puede tener su servidor y los clientes integrados a través de FireLoop, independientemente del directorio del sistema de archivos. De todos modos, en algunos casos tiene sentido tener todo en 1 lugar; Y el mejor de los ejemplos será la integración Angular Universal, que realmente necesita ser servida desde el servidor LoopBack. Ok .. fresco, ahora que he aclarado cómo personalizar la estructura del proyecto, vamos a tener un poco de diversión mediante la construcción de nuestra aplicación cliente en tiempo real. Actualizar el AppModuleEn primer lugar, permite abrir el fireloop_project / webapp / src / app / app.module.ts y decir Angular 2 que queremos utilizar el módulo Ng2Charts. 12345678910111213141516171819202122import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123; FormsModule &#125; from '@angular/forms';import &#123; SDKModule &#125; from './shared/sdk/index';import &#123; AppComponent &#125; from './app.component';import &#123; ChartsModule &#125; from 'ng2-charts/ng2-charts';@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule, FormsModule, SDKModule.forRoot(), ChartsModule ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; Impresionante, tan simple como que nuestra aplicación Angular 2 está lista para empezar a representar gráficos en tiempo real. Agregar logica del FireloopPermite ahora actualizar nuestro archivo fireloop_project /webapp/src/app/app.component.ts de la siguiente manera: 1234567891011121314151617181920212223242526272829303132333435import &#123; Component &#125; from '@angular/core';import &#123; Todo, FireLoopRef &#125; from './shared/sdk/models';import &#123; RealTime &#125; from './shared/sdk/services';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; private title : string = 'Todo app works!'; private todo : Todo = new Todo(); private todoRef : FireLoopRef&lt;Todo&gt;; constructor(private rt: RealTime) &#123; this.rt.onReady().subscribe(() =&gt; &#123; this.todoRef = this.rt.FireLoop.ref&lt;Todo&gt;(Todo); this.todoRef.stats().subscribe((stats: any) =&gt; console.log(stats)); &#125;); &#125; create(): void &#123; this.todoRef.create(this.todo).subscribe(() =&gt; this.todo = new Todo()); &#125; update(todo: Todo): void &#123; this.todoRef.upsert(todo).subscribe(); &#125; remove(todo: Todo): void &#123; this.todoRef.remove(todo).subscribe(); &#125;&#125; Creo que este código es bastante sencillo, básicamente sólo tiene que crear 1 Todo Modelo instancia, 1 FireLoop Reference y un par de métodos para envolver la funcionalidad, con excepción de que es cuestión de conectar las piezas juntas. Si ya lo has descubierto, deberías saberlo de una manera realmente inteligente … Tienes acceso dentro de tu cliente Angular 2 a tus modelos de backend, en este caso creamos un Todo Model que funciona a través de los extremos trasero y frontal. La otra pieza súper importante de aquí es FireLoop Reference, este servicio le permite sincronizar sus aplicaciones cliente con el servidor back-end, proporcionándole métodos que le permiten crear, actualizar, eliminar, escuchar cambios y escuchar estadísticas. Un buen ejemplo se puede ver dentro del constructor, estamos suscribiendo al método stats para escuchar estadísticas en tiempo real, esto es realmente genial.1234constructor(private rt: RealTime) &#123; this.todoRef = this.rt.FireLoop.ref&lt;Todo&gt;(Todo); this.todoRef.stats().subscribe((stats: any) =&gt; console.log(stats));&#125; Es genial, cada vez que algo cambia dentro de FireLoop Todo, obtendrás información estadística sobre él, pero … En este momento estamos enviando a la consola nuestras estadísticas, vamos a agregar la lógica del gráfico. Agregar logica del Ng2ChartsLo que estoy agregando aquí es sólo la configuración estándar para un gráfico de líneas que tomé de su documentación. Nuestro app.component.ts finalmente será algo como: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465require('chart.js');import &#123; Component &#125; from '@angular/core';import &#123; Todo, FireLoopRef &#125; from './shared/sdk/models';import &#123; RealTime &#125; from './shared/sdk/services';import * as moment from 'moment';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; private title : string = 'Todo app works!'; private todo : Todo = new Todo(); private todoRef : FireLoopRef&lt;Todo&gt;; private lineChartData:Array&lt;any&gt; = []; private lineChartLabels:Array&lt;any&gt; = []; private lineChartOptions:any = &#123; animation: false, responsive: false &#125;; private lineChartColors:Array&lt;any&gt; = [ &#123; backgroundColor: 'rgba(148,159,177,0.2)', borderColor: 'rgba(148,159,177,1)', pointBackgroundColor: 'rgba(148,159,177,1)', pointBorderColor: '#fff', pointHoverBackgroundColor: '#fff', pointHoverBorderColor: 'rgba(148,159,177,0.8)' &#125; ]; private lineChartLegend:boolean = true; private lineChartType:string = 'line'; constructor(private rt: RealTime) &#123; this.rt.onReady().subscribe(() =&gt; &#123; this.todoRef = this.rt.FireLoop.ref&lt;Todo&gt;(Todo); this.todoRef.stats().subscribe((stats: any) =&gt; &#123; this.lineChartLabels = new Array(); this.lineChartData = new Array(); let data = new Array(); stats.forEach((stat: any) =&gt; &#123; data.push(stat.count); this.lineChartLabels.push(moment(stat.universal).format('MM-YYYY')); &#125;); this.lineChartData.push(&#123; data: data, label: 'Number of Dued Todos'&#125;); &#125;); &#125;); &#125; create(): void &#123; this.todoRef.create(this.todo).subscribe(() =&gt; this.todo = new Todo()); &#125; update(todo: Todo): void &#123; this.todoRef.upsert(todo).subscribe(); &#125; remove(todo: Todo): void &#123; this.todoRef.remove(todo).subscribe(); &#125;&#125; Aquí solo estamos agregando un par de configuraciones para decidir qué colores usar, etc. Pero deberías ser capaz de ver que ahora estamos mapeando nuestras estadísticas para ser renderizadas por Ng2Charts. Actualizar vista de componente de aplicaciónPermite ahora actualizar nuestro archivo fireloop_project/webapp/src/app/app.component.html de la siguiente manera: 12345678910111213141516171819202122232425262728&lt;h1&gt; &#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;form (submit)=\"create()\"&gt; &lt;input name=\"todo\" type=\"text\" [(ngModel)]=\"todo.text\" placeholder=\"Add Todo\" /&gt; &lt;input name=\"todo\" type=\"date\" [(ngModel)]=\"todo.dueAt\" placeholder=\"Due Date\" /&gt; &lt;button&gt;Add Todo&lt;/button&gt;&lt;/form&gt;&lt;ul&gt; &lt;li *ngFor=\"let _todo of todoRef.on('change') | async\"&gt; &lt;input name=\"_todo.id\" [(ngModel)]=\"_todo.text\" /&gt; &lt;button (click)=\"update(_todo)\"&gt;Update&lt;/button&gt; &lt;button (click)=\"remove(_todo)\"&gt;Remove&lt;/button&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt; &lt;div style=\"display: block;\"&gt; &lt;canvas *ngIf=\"lineChartData.length &gt; 0\" baseChart width=\"400\" height=\"400\" [datasets]=\"lineChartData\" [labels]=\"lineChartLabels\" [options]=\"lineChartOptions\" [colors]=\"lineChartColors\" [legend]=\"lineChartLegend\" [chartType]=\"lineChartType\"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Cool, ¿qué tan fácil fue eso? Simplemente enlazamos todo lo relacionado con nuestra lógica de componentes y aquí estamos, con una aplicación en tiempo real de pila completa que está lista para ser probada. TestAhora ejecutamos nuestro buff de proyecto fireloop ejecutando $ fireloop service y luego seleccionamos ambos, tu cliente y servidor usando la barra de sapace y luego solo pulsamos return para cargarlos. 123456789101112131415161718$ fireloop serve _-----_ | | ╭──────────────────────────╮ |--(o)--| │ Let's serve an │ `---------´ │ application! │ ( _´U`_ ) ╰──────────────────────────╯ /___A___\\ / | ~ | __'.___.'__ ´ ` |° ´ Y ` ? What application do you want to serve? (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)❯◯ webapp ◯ server ... Loading Client Application: webapp Loading Server Application: server Y Voilà … Sólo tienes que abrir el navegador 2 en http://127.0.0.1:4200 para que puedas verificar que ambos se actualizan en tiempo real. FireLoop Stats Gif Example","categories":[],"tags":[]},{"title":"Creando el SDK para el Cliente","slug":"creating-client-sdk","date":"2017-05-04T21:13:32.975Z","updated":"2017-05-04T21:13:32.975Z","comments":true,"path":"es/creating-client-sdk/","link":"","permalink":"http://fireloop.io/es/creating-client-sdk/","excerpt":"","text":"La integración FireLoop se construye en el SDK, por lo que sólo necesita generar uno e instalarlo mediante la herramienta CLI. 1234567891011121314151617181920$ cd myproject$ fireloop _-----_ ╭──────────────────────────╮ | | │ Welcome to FireLoop! │ |--(o)--| │ The MEAN Stack Platform │ `---------´ │ by MEAN Expert │ ( _´U`_ ) ╰──────────────────────────╯ /___A___\\ / | ~ | __'.___.'__ ´ ` |° ´ Y `? What do you want to do? Generate Angular2 SDK? For which application do you want to build an SDK? (Use arrow keys)❯ webapp? What SDK features do you want to include? (*) Enable PubSub + IO + FireLoop functionality&gt;(*) Add default values in models? Do you want to generate ONLY FireLoop SDK + Auth Services? (Y/n) Es importante tener en cuenta que debe [crear una aplicación] utilizando la herramienta FireLoop CLI antes de este procedimiento. Además, al crear nuevos modelos FireLoop, puede que desee reconstruir el SDK para cualquiera de sus aplicaciones cliente siguiendo el mismo procedimiento que seguimos. Tenga en cuenta que la opción FireLoop sólo se presentará si IO está habilitada.","categories":[],"tags":[]},{"title":"Hola Mundo","slug":"hello-world","date":"2017-05-04T21:13:32.975Z","updated":"2017-05-04T21:13:32.975Z","comments":true,"path":"es/hello-world/","link":"","permalink":"http://fireloop.io/es/hello-world/","excerpt":"","text":"Bienvenido a [Hexo] (https://hexo.io/)! Este es tu primer post. Consulte [documentación] (https://hexo.io/docs/) para obtener más información. Si tienes algún problema al usar Hexo, puedes encontrar la respuesta en [solución de problemas] (https://hexo.io/docs/troubleshooting.html) o puedes preguntarme sobre [GitHub] (https://github.com/hexojs/hexo/issues). Inicio rapidoCrear un nuevo post1$ hexo new \"Mi nuevo post\" Mas info: Writing Correr Servidor1$ hexo server Mas info: Server Generar Archivos Estaticos1$ hexo generate Mas info: Generating Deploy a sitios remotos1$ hexo deploy Mas info: Deployment","categories":[],"tags":[]},{"title":"Inicio Rapido","slug":"getting-started","date":"2017-05-04T21:13:32.975Z","updated":"2017-05-04T21:13:32.975Z","comments":true,"path":"es/getting-started/","link":"","permalink":"http://fireloop.io/es/getting-started/","excerpt":"","text":"FireLoop Es una Plataforma en Real-time para NodeJS que le permite crear aplicaciones modernas y complejas integrando a la perfección las sorprendentes tecnologias de MEAN Stack como frameworks IBM Loopback, Google Angular 2, Telerik’s NativeScript 2 y Ionic 2 FireLoop También le ofrece módulos exclusivos que le permitirán crear automáticamente sus APIs en tiempo real, los SDKs de clientes, las estadísticas como FireBase, Backend y Frontend desarrollado en TypeScript!!!. Por cierto, es fresco y de código abierto!!! Instalacion1$ npm install -g @mean-expert/fireloop Características de FireLoop Configuración agradable y fácil. 1 herramienta de línea de comandos para todos (Server, Web Clients, Mobile Clients, SDK Builder). Back y Front en TypeScript. Integracion con LoopBack 2 y 3. Integracion con Angular 2. Integracion con NativeScript 2. Integracion con Ionic 2. Integracion con SDK Builder. Integracion con Real-Time.","categories":[],"tags":[]},{"title":"Api","slug":"api","date":"2017-05-04T21:13:32.975Z","updated":"2017-05-04T21:13:32.975Z","comments":true,"path":"es/api/","link":"","permalink":"http://fireloop.io/es/api/","excerpt":"","text":"Debería [crear una aplicación] y software development kit utilizando la Herramienta de CLI FireLoop antes de poder utilizar la siguiente API. Importación de servicio RealTimeEl LoopBack SDK Builder generará y proporcionará un servicio Angular 2 que se puede inyectar dentro de nuestro constructor de la siguiente manera: 12345678910import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';@Component(...)export class AppComponent &#123; constructor(private realTime: RealTime) &#123; this.realTime.FireLoop // explore with intellisense &#125;&#125; Esperando la conexiónAl utilizar cualquier característica en tiempo real, primero debe asegurarse de que su aplicación cliente está conectada con el servidor a través de sockets web. El siguiente ejemplo ilustra cómo esperar a que se establezca una conexión mediante el método onReady. 1234567891011121314import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';@Component(...)export class AppComponent &#123; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; &#123; // Register FireLoop References in here.... &#125;); &#125;&#125; Cómo crear datosEl siguiente ejemplo creará una nueva instancia de sala a través de la nueva API FireLoop utilizando WebSockets en lugar del protocolo API de REST de HTTP estándar LoopBack. 12345678910111213141516171819202122import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private room: Room = new Room(&#123; name: 'Hello FireLoop Room' &#125;); private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) ); &#125; create(): void &#123; this.RoomReference.create(this.room).subscribe((instance: Room) =&gt; console.log(instance)); &#125;&#125; Siempre habrá una nueva instancia creada después de usar el método create, pero también puede usarupsert que create o el update de la instancia. 1234567891011121314151617181920212223import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private room: Room = new Room(&#123; name: 'Hello FireLoop Room' &#125;); private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) ); &#125; upsert(): void &#123; this.RoomReference.upsert(this.room).subscribe((instance: Room) =&gt; console.log(instance)); &#125;&#125; Utilizando upsert, FireLoop comprobará si el elemento ya se ha persistido y lo actualiza, de lo contrario creará una nueva instancia. Cómo quitar datosEl ejemplo siguiente eliminará una instancia de sala a través de la nueva API FireLoop que usa WebSockets. 1234567891011121314151617181920212223import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private room: Room = new Room(&#123; name: 'Hello FireLoop Room' &#125;); private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) ); &#125; remove(room: Room): void &#123; this.RoomReference.remove(room).subscribe((removed: Room) =&gt; &#123;&#125;); &#125;&#125; Eventos disponibles Event Description change Este evento devolverá una matriz de elementos persistentes y continuará disparando en cualquier cambio para la referencia de modelo actual. value Este evento devolverá una matriz de elementos persistentes y continuará disparando cuando se agreguen nuevos valores en la referencia de modelo actual. child_changed Este evento se disparará una vez por cada elemento persistido y continuará disparando cuando se agreguen nuevos valores en la Referencia del Modelo actual, devolviendo sólo el elemento hijo recién creado child_removed Este evento se disparará una vez para cada elemento cambiado Leer datos utilizando el evento ‘change’Este es el evento de lectura recomendado para las listas en tiempo real porque estará sincronizado en cualquier momento en que haya una modificación de referencia; Esto significa que en cualquier adición, eliminación o modificación de cualquier niño dentro de la referencia activará una sincronización de cliente. 12345678910111213141516171819import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) this.RoomReference.on('change').subscribe((rooms: Array&lt;Room&gt;) =&gt; console.log(rooms)); ); &#125;&#125; Leer datos utilizando el evento ‘value’Similar a Firebase, ahora puede escuchar los cambios de referencias suscribiéndose al evento value. 12345678910111213141516171819import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) this.RoomReference.on('value').subscribe((rooms: Array&lt;Room&gt;) =&gt; console.log(rooms)); ); &#125;&#125; El ejemplo anterior lista los elementos persistentes (Salas) la primera vez y continuará disparando cada vez que haya un nuevo valor agregado. Cuando no se define la consulta, el evento value devolverá los últimos 100 registros de la base de datos. Escucha el evento ‘child_added’12345678910111213141516171819import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) this.RoomReference.on('child_added').subscribe((room: Room) =&gt; console.log(room)); ); &#125;&#125; Escucha el evento ‘child_changed’12345678910111213141516171819import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) this.RoomReference.on('child_changed').subscribe((room: Room) =&gt; console.log(room)); ); &#125;&#125; Escucha el evento ‘child_removed’12345678910111213141516171819import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) this.RoomReference.on('child_removed').subscribe((room: Room) =&gt; console.log(room)); ); &#125;&#125; Consultar datosDesde el construido en LoopBack Query Language es realmente maduro, decidí seguir usando para permitir que tire de la información de acuerdo a sus necesidades. 1234567891011121314151617181920212223import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) this.RoomReference.on('change',&#123; limit: 10, order: 'id DESC', include: 'members' &#125;).subscribe((rooms: Room[]) =&gt; console.log(rooms)); ); &#125;&#125; Para obtener más información acerca de cómo consultar datos, consulte la siguiente documentation Trabajar con referencias de ChildTrabajar con referencias Child le permitirá persistir una relación entre un padre y una referencia de niño. Por ejemplo, al crear mensajes en una sala de chat, queremos que se persistan dentro de la habitación correcta. 1234567891011121314151617181920212223242526272829import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, Message, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private RoomReference: FireLoopRef&lt;Room&gt;; private MessageReference: FireLoopRef&lt;Message&gt;; private room: Room = new Room(&#123; name: 'FireLoop Room' &#125;); private message: Room = new Message(&#123; text: 'Test Message' &#125;); constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) this.RoomReference.upsert(this.room).subscribe((instance: Room) =&gt; &#123; // Create a Child Reference this.MessageReference = RoomReference.make(instance).child&lt;Message&gt;('messages'); this.MessageReference.on('value').subscribe( (messages: Array&lt;Message&gt;) =&gt; this.logger.info(messages) ); MessageReference.upsert(this.message).subscribe((res: Message) =&gt; console.log(res.text)); &#125;)) ); &#125;&#125; El ejemplo anterior creará una nueva Sala y luego creará una MessageReference, ahora puede almacenar o escuchar mensajes dentro de esta sala específica. Todo lo relacionado con esta referencia persistirá la relación Parent -&gt; Child.","categories":[],"tags":[]},{"title":"Tabla de comparación","slug":"comparison-table","date":"2017-05-04T21:13:32.975Z","updated":"2017-05-04T21:13:32.975Z","comments":true,"path":"es/comparison-table/","link":"","permalink":"http://fireloop.io/es/comparison-table/","excerpt":"","text":"Tabla de comparación Plataforma Meteor Horizon FireBase FireLoop Description Plataforma de código abierto para web, móvil y escritorio. Real-time platform built on top of RethinkDB. BackEnd as A Service para el desarrollo de aplicaciones clientes plataforma en Real-time basada en LoopBack and Express.js. Real-Time Si Si Si Si UI Components Si No No No UI pero WebRTC Componentes para Angular 2 están en desarrollo. Client SDK Monolithic JavaScript Client SDKs para diferentes lenguajes Full tipado Angular 2 SDK Extensibilidad Meteor Modules Todavía no implementado Mecanismo de complemento o pluguin Nope Isomorphica (Universal) Models, Hooks, Mixins y Componentes. Escalabilidad Usa MongoDB OpLog Usa RethinkDB Escalado automático Arquitectura impulsada por adaptador o driver (Options: MongoDB PubSub, Redis, Kafka, Build your own driver) Madurez Very mature No es tan madura, muchas piezas no están en su lugar Muy madura Madura ya que se basa en LoopBack Maturity plus Modern Community Modules. Open Source Si Si No Si","categories":[],"tags":[]},{"title":"Creación de aplicaciones cliente","slug":"creating-client-apps","date":"2017-05-04T21:13:32.975Z","updated":"2017-05-04T21:13:32.975Z","comments":true,"path":"es/creating-client-apps/","link":"","permalink":"http://fireloop.io/es/creating-client-apps/","excerpt":"","text":"12345678910111213141516$ cd myproject$ fireloop? What do you want to do? Generate Angular2 Client _-----_ | | ╭──────────────────────────╮ |--(o)--| │ Lets's create an Angular │ `---------´ │ 2 Application! │ ( _´U`_ ) ╰──────────────────────────╯ /___A___\\ / | ~ | __'.___.'__ ´ ` |° ´ Y ` ? What type of Angular 2 Application do you want to create? 1.- Angular 2 Web? What's the name of your application? (webapp) Una vez creada su aplicación, automáticamente habrá instalado su [kit de desarrollo de software], pero cada vez que [cree un nuevo modelo]; Deberá volver a crear su SDK siguiendo estas instrucciones.","categories":[],"tags":[]},{"title":"Creating Client SDK","slug":"creating-client-sdk","date":"2017-05-04T21:13:32.971Z","updated":"2017-05-04T21:13:32.971Z","comments":true,"path":"en/creating-client-sdk/","link":"","permalink":"http://fireloop.io/en/creating-client-sdk/","excerpt":"","text":"The FireLoop integration is built in the SDK, so you just need to generate one and install it by using the CLI Tool. 1234567891011121314151617181920$ cd myproject$ fireloop _-----_ ╭──────────────────────────╮ | | │ Welcome to FireLoop! │ |--(o)--| │ The MEAN Stack Platform │ `---------´ │ by MEAN Expert │ ( _´U`_ ) ╰──────────────────────────╯ /___A___\\ / | ~ | __'.___.'__ ´ ` |° ´ Y `? What do you want to do? Generate Angular2 SDK? For which application do you want to build an SDK? (Use arrow keys)❯ webapp? What SDK features do you want to include? (*) Enable PubSub + IO + FireLoop functionality&gt;(*) Add default values in models? Do you want to generate ONLY FireLoop SDK + Auth Services? (Y/n) It is important to note that you should create an application by using the FireLoop CLI Tool prior this procedure. Also, when you create new FireLoop Models, you may want to rebuild the SDK for any of your client applications using the same procedure we just followed. Note that the FireLoop option will only be presented if IO is enabled.","categories":[],"tags":[]},{"title":"Comparison Table","slug":"comparison-table","date":"2017-05-04T21:13:32.971Z","updated":"2017-05-04T21:13:32.971Z","comments":true,"path":"en/comparison-table/","link":"","permalink":"http://fireloop.io/en/comparison-table/","excerpt":"","text":"Comparison Table Platform Meteor Horizon FireBase FireLoop Description Open source platform for web, mobile and desktop. Real-time platform built on top of RethinkDB. BaaS Cloud platform for fast development of client Applications. Real-time platform built on top of LoopBack and Express.js. Real-Time Yes Yes Yes Yes UI Components Yes No No Not UI but WebRTC Components for Angular 2 are under development. Client SDK Monolithic JavaScript Client SDKs for different languages Fully Typed Angular 2 SDK Extensibility Meteor Modules Not yet implemented Plug-In mechanism None Isomorphic (Universal) Models, Hooks, Mixins and Components. Scalability Uses MongoDB OpLog Uses RethinkDB Auto-scaling Adapter Driven Architecture (Options: MongoDB PubSub, Redis, Kafka, Build your own driver) Maturity Very mature Not so mature, many pieces are not in place Very Mature Mature since it relies on LoopBack Maturity plus Modern Community Modules. Open Source Yes Yes No Yes","categories":[],"tags":[]},{"title":"Scaling FireLoop","slug":"scaling-fireloop","date":"2017-05-04T21:13:32.971Z","updated":"2017-05-04T21:13:32.971Z","comments":true,"path":"en/scaling-fireloop/","link":"","permalink":"http://fireloop.io/en/scaling-fireloop/","excerpt":"","text":"FireLoop.io Scaling FireLoopBuilding apps with FireLoop is nice and easy, but that would be worthless if the platform wouldn’t scale into multiple server or even process instances. The following documentation will explain how to enable FireLoop to work under clustered environments. Requirements SDK Builder v2.1.0-rc.10+ LoopBack Component Real-Time v1.0.0-rc.5+ Socket IO Adapter (Any valid socket.io-adapter like socket.io-adapter-mongo, socket.io-redis, etc) PubSub capable database like MongoDB or Redis Creating DataSourceRegardless the datasource you select for your API Models, you will need to create a datasource pointing to a MongoDB or Redis database. If you already selected MongoDB or Redis database for your API Models, you won’t need to create a new datasource, users using any other databases like SQL ones, will require to create a new datasource pointing to MongoDB or Redis and install its LoopBack dependency. 12$ cd to/project/api$ npm install --save [loopback-connector-mongodb | loopback-connector-redis] and configure as any other LoopBack datasource, example: 1234567&#123; \"mongodb\": &#123; \"url\": \"mongodb://user:pass@host:27016/dbname\", \"name\": \"mongodb\", \"connector\": \"mongodb\" &#125;&#125; server/datasources.json Enable Clustering ModeIn order to enable the clustering mode, we need to set the following configurations: 123456789101112131415&#123; \"@mean-expert/loopback-component-realtime\": &#123; \"auth\": true, \"debug\": false, \"driver\": &#123; \"name\": \"socket.io\", \"options\": &#123; \"adapter\": &#123; \"name\": \"socket.io-adapter-mongo\", \"datasource\": \"mongodb\" &#125; &#125; &#125; &#125;&#125; Please note that the adapter.name should be the adapter you selected and installed prior this process, as well as the adapter.datasource should be the name of the datasource you created. After following the configurations above, FireLoop will work either on clustered process or server environments.","categories":[],"tags":[]},{"title":"Real Time Stats Example","slug":"realtime-stats-example","date":"2017-05-04T21:13:32.971Z","updated":"2017-05-04T21:13:32.971Z","comments":true,"path":"en/realtime-stats-example/","link":"","permalink":"http://fireloop.io/en/realtime-stats-example/","excerpt":"","text":"Real-Time Project DescriptionTo demonstrate what can be achieved with FireLoop, I have decided to create an application that will render statistical charts with real-time data coming from a FireLoop project. This will be kind of a regular Todo Application, but this time we will set a due date for our todos, this way we can render some statistical information about it and play better with it. Project RepositoryFor this example I have created a repository that you can use as playground. CLICK HERE FOR GITHUB REPO Install FireLoopOf course, the very first step we’ll want to take, is to install our FireLoop CLI Tool. 1$ npm install -g @mean-expert/fireloop Create FireLoop ProjectNow that we have our FireLoop CLI Tool installed, we can go ahead and create our first FireLoop Project. In order to create a FireLoop Project, you will need to create a new folder directory in any file system location of your preference, then run the $ fireloop command and finally hit return for all of the displayed options. 1234567891011121314151617181920212223242526272829303132$ mkdir fireloop_project &amp;&amp; cd fireloop_project$ fireloop _-----_ ╭──────────────────────────╮ | | │ Welcome to FireLoop! │ |--(o)--| │ The MEAN Stack Platform │ \\`---------´ │ by MEAN Expert │ ( _´U`_ ) ╰──────────────────────────╯ /___A___\\ / | ~ | __'.___.'__ ´ ` |° ´ Y \\` ? What do you want to do? (Use arrow keys)❯ Generate FireLoop Project Show FireLoop Version ? What\\'s the name of your application? fireloop_project? Which version of LoopBack would you like to use? 2.x (stable)? What kind of application do you have in mind? api-server (A LoopBack API server with local User auth)Next steps: Create a model in your server $ fireloop model [ModelName] Create a new Angular 2 Client or SDK $ fireloop Serve an application $ fireloop serve Great, now we have created a FireLoop Project with the minimum amount of effort. So… what if we follow the Next Steps tips and then we just create our Todo Model. Create Todo ModelFor this we are going to use the $ fireloop model [ModelName] command and then add a couple of properties. Basically you just hit return until you reach the properties section and you add the text: string &amp;&amp; dueAt: date attributes. 123456789101112131415161718192021222324252627282930$ fireloop model Todo? Enter the model name: Todo? Select the data-source to attach Todo to: db (memory)? Select model´s base class PersistedModel? Expose Todo via the REST API? Yes? Custom plural form (used to build REST URL): ? Common model or server only? commonLet´s add some Todo properties now. Property text: stringEnter an empty property name when done.? Property name: text? Property type: string? Required? Yes? Default value[leave blank for none]: Property dueAt: dateLet´s add another Todo property.Enter an empty property name when done.? Property name: dueAt? Property type: date? Required? Yes? Default value[leave blank for none]: Let´s add another Todo property.Enter an empty property name when done.? Property name: Generating: ./common/models/todo.ts If you have been using LoopBack, you will notice that under the hood I’m using the loopback generator for this operation, but at the end; The FireLoop CLI Tool takes control and it will create a modified version of a LoopBack Model. If you open the ./common/models/todo.ts file, you will find the new TypeScript structure for our Back End Models. 123456789101112131415161718192021222324252627282930313233343536import &#123; Model &#125; from '@mean-expert/model';/** * @module Todo * @description * Write a useful Todo Model description. * Register hooks and remote methods within the * Model Decorator **/@Model(&#123; hooks: &#123; beforeSave: &#123; name: 'before save', type: 'operation' &#125; &#125;, remotes: &#123; myRemote: &#123; returns : &#123; arg: 'result', type: 'array' &#125;, http : &#123; path: '/my-remote', verb: 'get' &#125; &#125; &#125;&#125;)class Todo &#123; // LoopBack model instance is injected in constructor constructor(public model: any) &#123;&#125; // Example Operation Hook beforeSave(ctx: any, next: Function): void &#123; console.log('Todo: Before Save'); next(); &#125; // Example Remote Method myRemote(next: Function): void &#123; this.model.find(next); &#125;&#125;module.exports = Todo; Any logic related to our Todo Model in the Back-End should be placed in this TypeScript File, though for this demo we are going to leave it as it is. But, what we really want to do is to update our Todo Model statistical configurations. Please open the file ./common/models/todo.json and update it as follows: 1234567891011121314&#123; ... \"mixins\": &#123; ... \"Stats\": [ &#123; ... \"count\": &#123; \"on\": \"dueAt\" // &lt;---- change createdAt for dueAt &#125; &#125; ] &#125;&#125; What we are doing here is to tell the stats mixing to rely on the dueAt property, this way our statistical information will be generated according the todo due dates instead of when the todo was created. Disable Auth FeatureFor this project and for practical purposes, we won’t use the authentication mechanism since I don’t want to spend time creating register/login sections, but I promise I will be creating a tutorial for authentication really soon. For this open the server/component-config.json file and modify as follows: 123456789&#123; \"loopback-component-explorer\": &#123; \"mountPath\": \"/explorer\" &#125;, \"@mean-expert/loopback-component-realtime\": &#123; \"auth\": false, // &lt;--- Change this to false \"debug\": false &#125;&#125; Ok, for this project… That is all we need to do within our Back End. Now, it is time to create our Angular 2 Client. Create Angular 2 Web ClientWe can create Angular 2 clients by using the FireLoop command: $ fireloop 1234567891011121314151617$ fireloop _-----_ ╭──────────────────────────╮ | | │ Welcome to FireLoop! │ |--(o)--| │ The MEAN Stack Platform │ `---------´ │ by MEAN Expert │ ( _´U`_ ) ╰──────────────────────────╯ /___A___\\ / | ~ | __'.___.'__ ´ ` |° ´ Y ` ? What do you want to do? (Use arrow keys)❯ Generate Angular2 Client ? What type of Angular 2 Application do you want to create? Angular 2 for Web? What's the name of your application? webapp When following the process described above, several thing happen under the hood. FireLoop internally uses Angular CLI to create an Angular 2 project. FireLoop generates a SDK for your new Angular 2 Client App to be fully connected with your LoopBack API. FireLoop installs the SDK and its dependencies, including types. At the end of the process you won’t need to worry about any integration or configuration, everything has been automatically done for you!!!.[Public cheering in the background] Install NG2 ChartsNow that you avoided a good amount of configurations and integrations, you are ready to start working over the client application. For this project I have decided to use Ng2Charts to render our charts, but you can also check this tutorial for building your own custom charts. 12$ cd webapp$ npm install --save ng2-charts chart.js moment Customizing The File System StructureAs you can see, you need to enter the webapp (or whatever name you chose for your app) directory and then install from there its own dependencies. This is because even-though you have a workspace for it, we want to keep the dependencies and the actual clients as decoupled as possible from the server. This means that you don’t need to have in 1 place the modules for the server and the modules for NativeScript because it does not make sense. So… Why then are we creating everything within the same project? The short answer is for convenience, because remember that FireLoop integrates for you a full stack solution, allowing you to automatically build sdks for any of your clients and adding exclusive real-time and statistical functionalities without any configuration or extra effort. But, if you don’t really like to have your webapp or any client within the same directory as the FireLoop project you can actually change that. Just open the .yo-rc.json file and update the client path to any location of your preference 123456789101112&#123; \"generator-fireloop\": &#123; \"version\": \"1.0.0-beta.1\", \"clients\": &#123; \"webapp\": &#123; \"path\": \"./webapp\", // &lt;--- Move your project out of the FireLoop directory and update the path reference here \"type\": \"web\" &#125; &#125; &#125;, \"generator-loopback\": &#123;&#125;&#125; Of course, you may want to move some of these clients away; because you may want to have separated repositories and just because it does’t make sense to have it in one place when talking about mobile applications. Just remember you can still have your server and clients integrated through FireLoop regardless of the file system directory. Anyway, in some cases it does make sense to have everything in 1 place; And the best of the examples will be the Angular Universal integration, that actually needs to be served from the LoopBack server. Ok.. cool, now that I clarified how to customize the project structure, lets have some fun by building our real-time client application. Update AppModuleFirst of all, lets open the fireloop_project/webapp/src/app/app.module.ts and tell Angular 2 that we want to use the Ng2Charts Module. 12345678910111213141516171819202122import &#123; BrowserModule &#125; from '@angular/platform-browser';import &#123; NgModule &#125; from '@angular/core';import &#123; FormsModule &#125; from '@angular/forms';import &#123; SDKModule &#125; from './shared/sdk/index';import &#123; AppComponent &#125; from './app.component';import &#123; ChartsModule &#125; from 'ng2-charts/ng2-charts';@NgModule(&#123; declarations: [ AppComponent ], imports: [ BrowserModule, FormsModule, SDKModule.forRoot(), ChartsModule ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; Awesome, as simple as that our Angular 2 Application is ready to start rendering real-time charts. Add FireLoop LogicLets now update our fireloop_project/webapp/src/app/app.component.ts file as follows: 1234567891011121314151617181920212223242526272829303132333435import &#123; Component &#125; from '@angular/core';import &#123; Todo, FireLoopRef &#125; from './shared/sdk/models';import &#123; RealTime &#125; from './shared/sdk/services';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; private title : string = 'Todo app works!'; private todo : Todo = new Todo(); private todoRef : FireLoopRef&lt;Todo&gt;; constructor(private rt: RealTime) &#123; this.rt.onReady().subscribe(() =&gt; &#123; this.todoRef = this.rt.FireLoop.ref&lt;Todo&gt;(Todo); this.todoRef.stats().subscribe((stats: any) =&gt; console.log(stats)); &#125;); &#125; create(): void &#123; this.todoRef.create(this.todo).subscribe(() =&gt; this.todo = new Todo()); &#125; update(todo: Todo): void &#123; this.todoRef.upsert(todo).subscribe(); &#125; remove(todo: Todo): void &#123; this.todoRef.remove(todo).subscribe(); &#125;&#125; I believe this code is pretty straight forward, basically you just need to create 1 Todo Model instance, 1 FireLoop Reference and a couple of methods to wrap the functionality, other than that is matter of connecting the pieces together. If you figured out already, you should know that in a really smart way… You have access within your Angular 2 client to your backend models, in this case we created a Todo Model that works across the Back and Front Ends. The other super important piece in here is the FireLoop Reference, this service allows you to sync your client applications with the back end server by providing you with methods that allow you to create, update, remove, listen for changes and listen for stats. A good example can be seen within the constructor, we are subscribing to the stats method in order to listen for real-time statistics, this is really cool. 1234constructor(private rt: RealTime) &#123; this.todoRef = this.rt.FireLoop.ref&lt;Todo&gt;(Todo); this.todoRef.stats().subscribe((stats: any) =&gt; console.log(stats));&#125; Great, every time something changes within the FireLoop Todo Reference, you will get some statistical information about it, but… At this moment we are just sending to the console our stats, lets add the chart logic. Add Ng2Charts LogicWhat I’m adding here is just the standard configuration for a line chart that I took from their documentation. Our app.component.ts will finally be something like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465require('chart.js');import &#123; Component &#125; from '@angular/core';import &#123; Todo, FireLoopRef &#125; from './shared/sdk/models';import &#123; RealTime &#125; from './shared/sdk/services';import * as moment from 'moment';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; private title : string = 'Todo app works!'; private todo : Todo = new Todo(); private todoRef : FireLoopRef&lt;Todo&gt;; private lineChartData:Array&lt;any&gt; = []; private lineChartLabels:Array&lt;any&gt; = []; private lineChartOptions:any = &#123; animation: false, responsive: false &#125;; private lineChartColors:Array&lt;any&gt; = [ &#123; backgroundColor: 'rgba(148,159,177,0.2)', borderColor: 'rgba(148,159,177,1)', pointBackgroundColor: 'rgba(148,159,177,1)', pointBorderColor: '#fff', pointHoverBackgroundColor: '#fff', pointHoverBorderColor: 'rgba(148,159,177,0.8)' &#125; ]; private lineChartLegend:boolean = true; private lineChartType:string = 'line'; constructor(private rt: RealTime) &#123; this.rt.onReady().subscribe(() =&gt; &#123; this.todoRef = this.rt.FireLoop.ref&lt;Todo&gt;(Todo); this.todoRef.stats().subscribe((stats: any) =&gt; &#123; this.lineChartLabels = new Array(); this.lineChartData = new Array(); let data = new Array(); stats.forEach((stat: any) =&gt; &#123; data.push(stat.count); this.lineChartLabels.push(moment(stat.universal).format('MM-YYYY')); &#125;); this.lineChartData.push(&#123; data: data, label: 'Number of Dued Todos'&#125;); &#125;); &#125;); &#125; create(): void &#123; this.todoRef.create(this.todo).subscribe(() =&gt; this.todo = new Todo()); &#125; update(todo: Todo): void &#123; this.todoRef.upsert(todo).subscribe(); &#125; remove(todo: Todo): void &#123; this.todoRef.remove(todo).subscribe(); &#125;&#125; Here we are just adding a couple of configurations to decide which colors to be used, etc. But you should be able to see that now we are mapping our stats to be rendered by Ng2Charts. Update App Component ViewLets now update our fireloop_project/webapp/src/app/app.component.html file as follows: 12345678910111213141516171819202122232425262728&lt;h1&gt; &#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;form (submit)=\"create()\"&gt; &lt;input name=\"todo\" type=\"text\" [(ngModel)]=\"todo.text\" placeholder=\"Add Todo\" /&gt; &lt;input name=\"todo\" type=\"date\" [(ngModel)]=\"todo.dueAt\" placeholder=\"Due Date\" /&gt; &lt;button&gt;Add Todo&lt;/button&gt;&lt;/form&gt;&lt;ul&gt; &lt;li *ngFor=\"let _todo of todoRef.on('change') | async\"&gt; &lt;input name=\"_todo.id\" [(ngModel)]=\"_todo.text\" /&gt; &lt;button (click)=\"update(_todo)\"&gt;Update&lt;/button&gt; &lt;button (click)=\"remove(_todo)\"&gt;Remove&lt;/button&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt; &lt;div style=\"display: block;\"&gt; &lt;canvas *ngIf=\"lineChartData.length &gt; 0\" baseChart width=\"400\" height=\"400\" [datasets]=\"lineChartData\" [labels]=\"lineChartLabels\" [options]=\"lineChartOptions\" [colors]=\"lineChartColors\" [legend]=\"lineChartLegend\" [chartType]=\"lineChartType\"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Cool, how easy was that? we just bind everything associated to our component logic and here we are, with a full stack real-time application that is ready to be tested. TestLets now run our fireloop project bu running $ fireloop serve and then select both, your client and server by using the sapace bar and then just hit return to load them. 123456789101112131415161718$ fireloop serve _-----_ | | ╭──────────────────────────╮ |--(o)--| │ Let's serve an │ `---------´ │ application! │ ( _´U`_ ) ╰──────────────────────────╯ /___A___\\ / | ~ | __'.___.'__ ´ ` |° ´ Y ` ? What application do you want to serve? (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)❯◯ webapp ◯ server ... Loading Client Application: webapp Loading Server Application: server And Voilà… Just open 2 browser in http://127.0.0.1:4200 so you can verify both are updated in real-time. FireLoop Stats Gif Example","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-05-04T21:13:32.971Z","updated":"2017-05-04T21:13:32.971Z","comments":true,"path":"en/hello-world/","link":"","permalink":"http://fireloop.io/en/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Creating FireLoop Models","slug":"creating-fireloop-models","date":"2017-05-04T21:13:32.971Z","updated":"2017-05-04T21:13:32.971Z","comments":true,"path":"en/creating-fireloop-models/","link":"","permalink":"http://fireloop.io/en/creating-fireloop-models/","excerpt":"","text":"When you start building a system, the fist thing you need to do right after your setup, is to start creating your API Models. This models are similar to LoopBack Models, but with a difference… This models will be created and executed using TypeScript instead of JavaScript. (POW!) Creating FireLoop Models1234567891011121314151617181920212223$ cd myproject$ fireloop model MyModel? Enter the model name: MyModel? Select the data-source to attach MyModel to: db (memory)? Select model's base class PersistedModel? Expose MyModel via the REST API? Yes? Custom plural form (used to build REST URL): ? Common model or server only? commonLet's add some MyModel properties now.Enter an empty property name when done.? Property name: text invoke loopback:property? Property type: string? Required? No? Default value[leave blank for none]: Let's add another MyModel property.Enter an empty property name when done.? Property name: Generating: ./common/models/my-model.ts If you have experience with LoopBack you will see it is the same creational flow, is just that as described before; The model will be created in TypeScript Language. Model StructureNow that your Models are in TypeScript you will see these are different in structure to the LoopBack ones, but it has the exact same functionality. 123456789101112131415161718192021222324252627282930313233343536import &#123; Model &#125; from '@mean-expert/model';/** * @module Todo * @description * Write a useful Todo Model description. * Register hooks and remote methods within the * Model Decorator **/@Model(&#123; hooks: &#123; beforeSave: &#123; name: 'before save', type: 'operation' &#125; &#125;, remotes: &#123; myRemote: &#123; returns : &#123; arg: 'result', type: 'array' &#125;, http : &#123; path: '/my-remote', verb: 'get' &#125; &#125; &#125;&#125;)class Todo &#123; // LoopBack model instance is injected in constructor constructor(public model: any) &#123;&#125; // Example Operation Hook beforeSave(ctx: any, next: Function): void &#123; console.log('Todo: Before Save'); next(); &#125; // Example Remote Method myRemote(next: Function): void &#123; this.model.find(next); &#125;&#125;module.exports = Todo;","categories":[],"tags":[]},{"title":"Serving Applications","slug":"serving-apps","date":"2017-05-04T21:13:32.971Z","updated":"2017-05-04T21:13:32.971Z","comments":true,"path":"en/serving-apps/","link":"","permalink":"http://fireloop.io/en/serving-apps/","excerpt":"","text":"FireLoop is able to run all of your project applications at once (including your server), for this you can use the fireloop serve command and select the applications you want to serve. 1234567891011121314151617$ cd myproject$ fireloop serve _-----_ | | ╭──────────────────────────╮ |--(o)--| │ Let's serve an │ `---------´ │ application! │ ( _´U`_ ) ╰──────────────────────────╯ /___A___\\ / | ~ | __'.___.'__ ´ ` |° ´ Y ` ? What application do you want to serve? (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to inverse selection)❯◯ webapp ◯ server It is important to note that both, client and server applications will be running in TypeScript and loaded with livereload mechanisms according the environment. This means that once your applications are running, these will be restared by any code modification and recompiled to be live reloaded.","categories":[],"tags":[]},{"title":"Getting Started","slug":"getting-started","date":"2017-05-04T21:13:32.971Z","updated":"2017-05-04T21:13:32.971Z","comments":true,"path":"en/getting-started/","link":"","permalink":"http://fireloop.io/en/getting-started/","excerpt":"","text":"FireLoop is a NodeJS Real-Time Platform that allows you to build modern and complex applications by seamlessly integrating the amazing technologies from the MEAN Stack; Like the IBM’s LoopBack, Google’s Angular 2, Telerik’s NativeScript 2 and Ionic 2 Frameworks. FireLoop also provides you with exclusive modules that will allow you to automatically build your FireBase alike Real-Time APIs, Client SDKs, Statistics, Back and Front Ends development in TypeScript!!!. By the way, it’s cool and open source!!! Installation1$ npm install -g @mean-expert/fireloop FireLoop Features Nice and easy setup. 1 command line tool for all (Server, Web Clients, Mobile Clients, SDK Builder). Back and Front Ends in TypeScript. LoopBack 2 and 3 Integration. Angular 2 Integration. NativeScript 2 Integration. Ionic 2 Integration. SDK Builder Integration. Real-Time Integraiton.","categories":[],"tags":[]},{"title":"Creating Client Applications","slug":"creating-client-apps","date":"2017-05-04T21:13:32.971Z","updated":"2017-05-04T21:13:32.971Z","comments":true,"path":"en/creating-client-apps/","link":"","permalink":"http://fireloop.io/en/creating-client-apps/","excerpt":"","text":"12345678910111213141516$ cd myproject$ fireloop? What do you want to do? Generate Angular2 Client _-----_ | | ╭──────────────────────────╮ |--(o)--| │ Lets's create an Angular │ `---------´ │ 2 Application! │ ( _´U`_ ) ╰──────────────────────────╯ /___A___\\ / | ~ | __'.___.'__ ´ ` |° ´ Y ` ? What type of Angular 2 Application do you want to create? 1.- Angular 2 Web? What's the name of your application? (webapp) After your application is created, it will automatically have installed your software development kit, but any time you create a new model; You will need to re-build your SDK by following this instructions.","categories":[],"tags":[]},{"title":"Api","slug":"api","date":"2017-05-04T21:13:32.971Z","updated":"2017-05-04T21:13:32.971Z","comments":true,"path":"en/api/","link":"","permalink":"http://fireloop.io/en/api/","excerpt":"","text":"You should create an application and software development kit by using the FireLoop CLI Tool before being able to use the following API. Importing RealTime ServiceThe LoopBack SDK Builder will generate and provide an Angular 2 service that can be injected within our constructor as follows: 12345678910import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';@Component(...)export class AppComponent &#123; constructor(private realTime: RealTime) &#123; this.realTime.FireLoop // explore with intellisense &#125;&#125; Waiting for ConnectionWhen using any real-time feature, you first need to make sure your client application is connected with the server through web sockets. The following example illustrates how to wait for a connection to be established by using the onReady method. 1234567891011121314import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';@Component(...)export class AppComponent &#123; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; &#123; // Register FireLoop References in here.... &#125;); &#125;&#125; How to Create DataThe following example will crate a new room instance through the new FireLoop API using WebSockets instead of the Standard LoopBack HTTP REST API protocol.12345678910111213141516171819202122import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private room: Room = new Room(&#123; name: 'Hello FireLoop Room' &#125;); private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) ); &#125; create(): void &#123; this.RoomReference.create(this.room).subscribe((instance: Room) =&gt; console.log(instance)); &#125;&#125; There will be always a new instance created after using the create method, but you can also use upsert which will create or update the instance. 1234567891011121314151617181920212223import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private room: Room = new Room(&#123; name: 'Hello FireLoop Room' &#125;); private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) ); &#125; upsert(): void &#123; this.RoomReference.upsert(this.room).subscribe((instance: Room) =&gt; console.log(instance)); &#125;&#125; By using upsert, FireLoop will verify if the item is already persisted and update it, otherwise it will create a new instance. How to Remove DataThe following example will remove a room instance through the new FireLoop API using WebSockets. 1234567891011121314151617181920212223import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private room: Room = new Room(&#123; name: 'Hello FireLoop Room' &#125;); private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) ); &#125; remove(room: Room): void &#123; this.RoomReference.remove(room).subscribe((removed: Room) =&gt; &#123;&#125;); &#125;&#125; Available Events Event Description change This event will return an array of persisted elements and will keep firing on any change for the current Model Reference value This event will return an array of persisted elements and will keep firing when new values are added in the current Model Reference child_added This event will fire once for each persisted items and will keep firing when new values are added in the current Model Reference, returning only the newly created child element child_changed This event will fire once for each changed item. It will return a reference of the updated element child_removed This event will fire once for each removed items It will return a reference of the removed element Read Data Using ‘change’ EventThis is the recommended read event for real-time lists because it will be in sync any time there is a reference modification; this means that at any addition, removal or modification of any child within the reference will trigger a client synchronization. 12345678910111213141516171819import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) this.RoomReference.on('change').subscribe((rooms: Array&lt;Room&gt;) =&gt; console.log(rooms)); ); &#125;&#125; Read Data Using ‘value’ EventSimilar to Firebase, you are now able to listen for references changes by subscribing to the value event. 12345678910111213141516171819import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) this.RoomReference.on('value').subscribe((rooms: Array&lt;Room&gt;) =&gt; console.log(rooms)); ); &#125;&#125; The example above will list the persisted items (Rooms) the first time and will keep firing every time there is a new value added. When not query is defined the value Event will return the latest 100 records from the database. Listen ‘child_added’ Event12345678910111213141516171819import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) this.RoomReference.on('child_added').subscribe((room: Room) =&gt; console.log(room)); ); &#125;&#125; Listen ‘child_changed’ Event12345678910111213141516171819import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) this.RoomReference.on('child_changed').subscribe((room: Room) =&gt; console.log(room)); ); &#125;&#125; Listen ‘child_removed’ Event12345678910111213141516171819import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) this.RoomReference.on('child_removed').subscribe((room: Room) =&gt; console.log(room)); ); &#125;&#125; Querying DataSince the built in LoopBack Query Language is really mature, I decided to keep using it in order to allow you pull the information according your necessities. 1234567891011121314151617181920212223import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private RoomReference: FireLoopRef&lt;Room&gt;; constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) this.RoomReference.on('change',&#123; limit: 10, order: 'id DESC', include: 'members' &#125;).subscribe((rooms: Room[]) =&gt; console.log(rooms)); ); &#125;&#125; For more information about how to query data see the following documentation Working with Child ReferencesWorking with child references will allow you to persist a relation between a parent and a child reference. For instance when creating messages in a room chat, we want these to be persisted within the right Room. 1234567891011121314151617181920212223242526272829import &#123; Component &#125; from '@angular/core';import &#123; RealTime &#125; from './shared/sdk/services';import &#123; Room, Message, FireLoopRef &#125; from './shared/sdk/models';@Component(...)export class AppComponent &#123; private RoomReference: FireLoopRef&lt;Room&gt;; private MessageReference: FireLoopRef&lt;Message&gt;; private room: Room = new Room(&#123; name: 'FireLoop Room' &#125;); private message: Room = new Message(&#123; text: 'Test Message' &#125;); constructor(private realTime: RealTime) &#123; this.realTime .onReady() .subscribe(() =&gt; this.RoomReference = this.realTime.FireLoop.ref&lt;Room&gt;(Room) this.RoomReference.upsert(this.room).subscribe((instance: Room) =&gt; &#123; // Create a Child Reference this.MessageReference = RoomReference.make(instance).child&lt;Message&gt;('messages'); this.MessageReference.on('value').subscribe( (messages: Array&lt;Message&gt;) =&gt; this.logger.info(messages) ); MessageReference.upsert(this.message).subscribe((res: Message) =&gt; console.log(res.text)); &#125;)) ); &#125;&#125; The example above will create a new Room and then will create a MessageReference, now you can store or listen for messages within this specific room. Everything related with this reference will persist the relationship Parent -&gt; Child.","categories":[],"tags":[]},{"title":"categories","slug":"categories/index","date":"2016-12-26T16:27:27.000Z","updated":"2017-05-04T21:13:32.971Z","comments":true,"path":"en/categories/index/","link":"","permalink":"http://fireloop.io/en/categories/index/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"tags","slug":"tags/index","date":"2016-12-26T16:26:41.000Z","updated":"2017-05-04T21:13:32.975Z","comments":true,"path":"en/tags/index/","link":"","permalink":"http://fireloop.io/en/tags/index/","excerpt":"","text":"","categories":[],"tags":[]}]}